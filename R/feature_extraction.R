#' @export feature_extraction
feature_extraction <- function(
    motif_ts_results,
    indices_output_folder,
    folder_extension = ".flac",
    cropped_images_path) {
  # get the names of the motif DFs
  has_motifs <- names(motif_ts_results$motif_dfs)

  # filter the list of time series data frames to just the ones which have motif
  # results
  motif_ts_has_motifs <- motif_ts_results$ts_motifs[has_motifs]
  # Split each dataframe by the file name
  # Returns a nested list, 1 list per data frame, with each list element being a
  # data frame for the corresponding file

  motif_ts_temp <- lapply(motif_ts_has_motifs, function(x) {
    split(x, x$FileName)
  })

  temp_names <- unlist(lapply(motif_ts_temp, function(x) names(x)))
  new_list <- unlist(motif_ts_temp, recursive = FALSE)
  names(new_list) <- temp_names

  my_list <- lapply(new_list, function(x) {
    index_temp <- names(x)[1]
    if (index_temp == "EventsPerSecond") {
      index <- "EVN"
    } else if (index_temp == "Entropy") {
      index <- "ENT"
    } else if (index_temp == "AcousticComplexity") {
      index <- "ACI"
    }
    list(
      df = x,
      index = index,
      folder_name = NULL,
      folder_path = NULL,
      img_path = NULL
    )
  })

  folder_names <- names(my_list)
  for (i in seq_along(my_list)) {
    my_list[[i]]$folder_name <- folder_names[i]
    my_list[[i]]$folder_path <- get_data_path(
      indices_output_folder,
      paste0(folder_names[i], folder_extension)
    )
  }

  cat("Searching for output folders generated by AP for ",
    length(new_list),
    " unique audio files that contained motifs.\n",
    sep = ""
  )

  for (folder in my_list) {
    if (dir.exists(folder$folder_path)) {
      cat("‚úîÔ∏è Folder found\n")
    } else {
      cat("üö® Folder not found: \n")
      cat("--> ", folder, "\n")
      cat("Check the folder name and extension\n")
    }
  }

  # search the matching folders for the index name, with extension .png
  for (index in seq_along(my_list)) {
    matching_image <- list.files(my_list[[index]]$folder_path,
      pattern = paste0(my_list[[index]]$index, ".png"),
      recursive = TRUE, full.names = TRUE
    )
    if (length(matching_image) > 0) {
      cat("‚úîÔ∏è Matching index image file found: ",
        basename(matching_image), "\n",
        sep = ""
      )
      my_list[[index]]$img_path <- matching_image
    } else {
      cat("üö® Matching index file not found: \n",
        matching_image, "\n",
        sep = ""
      )
    }
  }

  # Summarise dataframes
  for (i in seq_along(my_list)) {
    df_summarised <- my_list[[i]]$df %>%
      dplyr::group_by(motif, length) %>%
      # remove NA rows
      dplyr::filter(!is.na(motif)) %>%
      dplyr::summarise(
        start = min(position)
        # length = length
      ) %>%
      dplyr::arrange(start)
    # normalise row minutes to length relative image width / spectrogram length
    row_minutes <- nrow(my_list[[i]]$df)
    df_summarised$start[df_summarised$start > row_minutes] <-
      df_summarised$start[df_summarised$start > row_minutes] - row_minutes
    # add end column which is start + length
    df_summarised_mut <- df_summarised %>%
      dplyr::mutate(end = start + length)

    df_summarised_mut$end[df_summarised_mut$end > row_minutes] <- row_minutes

    my_list[[i]]$df_summarised <- df_summarised_mut
  }
  my_list_img <- lapply(my_list, function(x) {
    img_temp_name <- substr(x$img_path, 1, nchar(x$img_path) - 4)
    x$img_temp_name <- img_temp_name
    return(x)
  })

  # create the image names ready for output
  my_list_img_next <- lapply(my_list_img, function(x) {
    image_names <- paste0(
      basename(x$img_temp_name),
      "_",
      x$df_summarised$motif,
      "_",
      x$df_summarised$start,
      "-",
      x$df_summarised$end,
      ".png"
    )
    x$image_names <- get_data_path(cropped_images_path, image_names)
    return(x)
  })
  # read in the image, create the crops, and save outputs
  for (i in seq_along(my_list_img_next)) {
    img <- magick::image_read(my_list_img_next[[i]]$img_path)
    for (j in seq_along(my_list_img_next[[i]]$image_names)) {
      img_width <- magick::image_info(img)$width
      crop_width <- my_list_img_next[[i]]$df_summarised$length[j] -
        (1 - my_list_img_next[[i]]$df_summarised$start[j])
      x_offset <- my_list_img_next[[i]]$df_summarised$start[j]
      if ((x_offset + crop_width) > img_width) {
        crop_width <- img_width - x_offset
      }
      img_crop <- magick::image_crop(
        img,
        magick::geometry_area(
          height = 316,
          width = crop_width,
          x_off = x_offset
        )
      )
      magick::image_write(img_crop, my_list_img_next[[i]]$image_names[j])
    }
  }
  return(my_list_img_next)
}

# Function to add "index" sub-item
#' @keywords internal
add_index <- function(x) {
  list(index = x, folder_name = NULL, folder_path = NULL, img_path = NULL)
}

split_convert_name <- function(motif_ts_df) {

}

#' Uses the names in list_out$folder_path to find the corresponding audio files
#' for images that have been used to create crops. Relies on audio files having
#' the same name as the folders created by AP (which is default behaviour)
#' @export find_matching_audio
find_matching_audio <- function(list_out, audio_source_dir) {
  audio_source_dir <- get_data_path(audio_source_dir)
  for (item in seq_along(list_out)) {
    sound_base <- basename(list_out[[item]]$folder_path)
    sound_base_esc <- stringr::str_escape(sound_base)
    sound_file <- list.files(
      audio_source_dir,
      pattern = paste0(sound_base_esc),
      recursive = TRUE,
      full.names = TRUE
    )
    if (length(sound_file) > 0) {
      cat("‚úîÔ∏è Matching audio file found: ",
        basename(sound_file), "\n",
        sep = ""
      )
      list_out[[item]]$audio_path <- sound_file
    } else {
      cat("üö® Matching audio file not found: \n",
        sound_file, "\n",
        sep = ""
      )
    }
  }
  return(list_out)
}

#' @export crop_audio
crop_audio <- function(list_out, output_dir) {
  output_dir <- get_data_path(output_dir)
  tally <<- 0
  # invisible(lapply(list_out, crop_audio_single, output_dir = output_dir))
  list_out_new <- lapply(list_out, crop_audio_single, output_dir = output_dir)
  cat("‚úîÔ∏è Audio cropping complete!\n")
  cat("‚úîÔ∏è ", tally, " Audio files saved to: ", output_dir, "\n", sep = "")
  return(list_out_new)
}

#' @keywords internal
crop_audio_single <- function(list_item, output_dir) {
  value <- find_program("ffmpeg")
  if (!value) {
    stop("ffmpeg not found. Please install ffmpeg, or make sure it is available
    in your path, and try again.")
  }

  df <- list_item$df_summarised
  df$audio_path <- list_item$audio_path
  audio_path_sub <- gsub(".flac", "", basename(list_item$audio_path))
  df$audio_out <- paste0(
    output_dir, "/",
    audio_path_sub,
    "_",
    df$motif,
    "_",
    df$start,
    "-",
    df$end,
    ".wav"
  )
  for (i in seq_len(nrow(df))) {
    # Construct ffmpeg command to crop audio file
    # convert minutes to seconds
    start <- df[i, "start"] * 60
    end <- df[i, "end"] * 60

    crop_cmd <- paste0(
      "ffmpeg -i ", shQuote(df$audio_path[[i]]),
      " -ss ", start, " -to ", end,
      " -c copy ", shQuote(df$audio_out[[i]])
    )

    # Execute ffmpeg command to crop audio file
    if (try(system(crop_cmd), silent = TRUE) == 0) {
      tally <<- tally + 1
    }
  }
  list_item$audio_crops <- df$audio_out
  return(list_item)
}
