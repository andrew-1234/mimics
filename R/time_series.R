#' Generate acoustic indices time series
#'
#' Output is a folder which contains .csv and .txt files of time series data for each acoustic index.
#' One file per index, per site, per month
#'
#' @param indicesfolder this is where your indices are saved
#' @param outputfolder this is where you would like the timeseries data saved
#'
#' @return a dataframe
#' @export
#'
#' @examples
#' time_series(indicesfolder = "output/indices-output-ap", outputfolder = "output/timeseries")
time_series <- function(indicesfolder, outputfolder) {

        site_id <- NULL
        point_id <- NULL
        date_time_id <- NULL
        month_id <- NULL
        geo_id <- NULL
        data_indices_all <- NULL

        # set the folder with indices
        folder <- indicesfolder

        # get a list of files with indices results
        # there should be one file per audio recording
        # TODO: this searches for the pattern generated by AP
        # in the future will have to support other patterns etc.
        file_list <- list.files(
                get_data_path(folder),
                pattern = ".Indices.csv",
                recursive = T,
                full.names = T
        )

        # run the read_indices function which returns the `data_indices_all` data frame
        indices_all_dataframe <- read_indices(files = file_list)

        # run the timeseries prep function, which returns a list
        subset_list <- timeseries_prep(indicesdata = indices_all_dataframe, outputfolder = outputfolder)

        # run the subset function
        subset_indices(indicesdata = indices_all_dataframe,
                       subsetlist = subset_list,
                       timeseriesfolder = outputfolder)
        return(indices_all_dataframe)
}


# This function runs a loop that generates metadata based on the file/folder names
# if your audio files aren't structured like this it won't work - TODO
# Need additional options to support metadata sources - lookup table etc.
# or if data is in a20 format - use default method (aka the current method)
# generate metadata from api call to a2O??
# support using a metadata table as input
# PROBLEM: i'm not sure if its just because only 2 minutes but every file has the same scaled indices values with the mini a20 dataset. update: just tested on the full set and the values weren't identical. just a scale issue with the small sample of 2 minutes audio per file.

#' Read indices function
#'
#' Combines ACI, ENT, TE indices data into a single data frame.
#' Uses / generates metadata based on the file/ folder names
#'
#' @param files your files
#'
#' @return
#' @export
#'
#' @examples
#' read_indices(files)
read_indices <- function(files) {
data_indices_all <- NULL
        for (file in files) {

        file_name_only_3 <- basename(file)
        # get geographic ID AKA study site/recording location ID
        u <- strsplit(file_name_only_3, split = "_")
        u2 <- unlist(u)
        u2[1]
        geo_id <- u2[2]
        geo_id <- unique(geo_id)

        # get date_time_ID
        date_time_id <- u2[1]

        # get month ID
        month_1 <- strsplit(date_time_id, split = "[+]") #strsplit is regex so need []
        month_2 <- unlist(month_1)
        month_3 <- month_2[1]
        month_4 <- lubridate::ymd_hms(month_3)
        month_5 <- lubridate::month(month_4, label = TRUE, abbr = TRUE)

        # specify the three indices we use. this is how they are formatted from AP
        indices <- c("AcousticComplexity", "EventsPerSecond", "TemporalEntropy")

        data_indices <- read.csv(file) %>%
                dplyr::mutate(FID = paste(file_name_only_3, ResultMinute, sep = "_")) %>%
                # separate FID, additional pieces discarded is the suffix: "__Towsey.Acoustic.Indices.csv_0"
                tidyr::separate(
                        .,
                        FID,
                        into = c("date_time", "site", "audioID"),
                        sep = "_",
                        remove = F,
                        extra = "drop"
                ) %>%
                tidyr::separate(
                        .,
                        date_time,
                        into = c("date", "time"),
                        sep = "T",
                        remove = F
                ) %>%
                tidyr::separate(
                        .,
                        time,
                        into = c("time", "offset"),
                        sep = "[+]",
                        remove = T
                ) %>%
                #mutate(., site = t[[1]][3]) %>%
                #mutate(., point = t[[1]][4]) %>%
                dplyr::mutate(., filepath = file) %>%
                # TODO: add the original audio file path?
                dplyr::mutate(., month = month_5) %>%
                dplyr::select(
                        .,
                        AcousticComplexity,
                        EventsPerSecond,
                        TemporalEntropy,
                        FileName,
                        date_time,
                        month,
                        date,
                        time,
                        ResultMinute,
                        FID,
                        site,
                        #point,
                        filepath
                ) %>%
                # This scales the acoustic indices using the inbuilt scale() function for each file
                dplyr::mutate_at(vars(all_of(indices)), scale) %>%
                # now this sorts the rows by date, time, and result minute.
                # important that the series is ordered. TODO CHECK: But i think this is working.
                # TODO: check as.numeric(date)
                with(., .[order(as.numeric(date), as.numeric(time), ResultMinute),])
        # bind all the files together
        data_indices_all <- rbind(data_indices_all, data_indices)
        }
        return(data_indices_all)
}


# unique(data_indices_all$FID)
# TODO maybe remove the __Towsey.Acoustic.Indices suffix to clean up names

# ---- use the DF generated in read_indices and save the subset output:

# total DFs = 3 * months * sensor locations
# so I should have 6 data frames

#' Time series prep
#'
#' Creates the output folder and creates the list that will be used for subsetting
#'
#' @param indicesdata
#' @param outputfolder
#'
#' @return
#' @export
#'
#' @examples
timeseries_prep <- function(indicesdata, outputfolder) {

        # one data frame per each of the three indices
        cols_all <- colnames(indicesdata)
        AC <- cols_all[!cols_all %in% c('EventsPerSecond', 'TemporalEntropy')]
        EV <- cols_all[!cols_all %in% c('AcousticComplexity', 'TemporalEntropy')]
        TE <- cols_all[!cols_all %in% c('EventsPerSecond', 'AcousticComplexity')]
        indices_subset_list <- list(AC, EV, TE)

        # where to store the output
        timeseries_input <- get_data_path(outputfolder)

        # create the output directory if it doesn't exist
        if (!dir.exists(timeseries_input)) {
                dir.create(timeseries_input)
        }

        return(indices_subset_list)
}


# this subsets into each index / site / month

# TODO: fix this loop to match time_processing_cont (start with the for calls one after another and check that it works)

#' Subset indices timeseries data for input to HIME
#'
#' The output here should be: files subset by geo/site ID (each sensor location), by month, by index
#'
#' @param indicesdata indices data
#' @param subsetlist list to subset by indices
#' @param timeseriesfolder where the output will be stored
#'
#' @return
#' @export
#'
#' @examples
#' subset_indices(indicesdata, subsetlist, timeseriesfolder)
subset_indices <- function(indicesdata, subsetlist, timeseriesfolder) {

        # prepare the grouping values, to subset and loop based on siteID, monthID
        total_sites <- unique(indicesdata$site)
        total_months <- unique(indicesdata$month)
        length_total_months <- length(total_months)

        # for each of the three indices
        for (x in subsetlist) {
                temp <- NULL
                temp2 <- NULL

                # subset by index (x in subset list)
                temp <- indicesdata %>% dplyr::select(all_of(unlist(x)))
                # subset by site
                for (sites in total_sites) {
                        temp2 <- temp %>% dplyr::filter(site == sites)
                        # TODO: (UNTESTED WITH MULTIPLE MONTHS of data)
                        for (month_id in total_months) {
                                temp3 <- temp2 %>% dplyr::filter(month == month_id)

                                # Sort the data by date_time and result minute
                                # TODO: sorting untested on larger date and time ranges
                                temp4 <- temp3 %>% dplyr::arrange(date_time, ResultMinute)

                                # create the output file ID
                                file_id_new <- paste(c("TS_",
                                                       unlist(x)[1], # gets the current index name
                                                       "_",
                                                       as.character(month_id), # get current month name
                                                       "_",
                                                       sites), # get current site name
                                                     collapse = "")

                                # TODO: maybe put csv and txt in different folders
                                utils::write.csv(
                                        x = temp4,
                                        file = paste(c(file.path(timeseriesfolder, file_id_new),
                                                ".csv"), collapse = ""))

                                utils::write.table(
                                        x = temp4[1], # just need the indices values for hime
                                        file = paste(c(file.path(timeseriesfolder, file_id_new),
                                               ".txt"), collapse = ""),
                                        row.names = F,
                                        col.names = F
                                )
                        }
                }
        }
}







